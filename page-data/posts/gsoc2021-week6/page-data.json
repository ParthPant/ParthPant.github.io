{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/gsoc2021-week6","result":{"data":{"markdownRemark":{"id":"644a954b-7824-509e-95ec-16ab5f364d54","html":"<p><img src=\"/0fd8119c475116ed1f982e06120ea265/recursive.gif\" alt=\"Image\"></p>\n<p>Once again, another week spent trying to make distribution snapping better in Inkscape!</p>\n<p>This blog is meant to give a high level description of how Distribution snapping\nis implemented as of now.</p>\n<h1 id=\"the-algorithm\" style=\"position:relative;\"><a href=\"#the-algorithm\" aria-label=\"the algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>“The Algorithm”</h1>\n<h2 id=\"collecting-the-objects\" style=\"position:relative;\"><a href=\"#collecting-the-objects\" aria-label=\"collecting the objects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Collecting the objects.</h2>\n<p>First we gather all of the relevant objects’ bounding boxes in the canvas. For this\nwe only look at objects that are visible in the viewing port. Bounding boxes are\ncollected in 4 separate lists, each for a different direction (right, left, up and down).</p>\n<p><em>any object that overlap the source object is ignored</em></p>\n<p>All these four lists are sorted so that the objects are arranged from closest to\nfarthest from the source object, in that direction respectively.</p>\n<p><img src=\"/f247f7fadd03f5ba9f61202784ae2047/collection.svg\" alt=\"Image\"></p>\n<h2 id=\"finding-equidistant-objects\" style=\"position:relative;\"><a href=\"#finding-equidistant-objects\" aria-label=\"finding equidistant objects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Finding equidistant objects</h2>\n<p>Once we have these four lists, the function <code class=\"language-text\">_findSidewaysSnaps</code> can look at each\nlist and collect a group of objects that are equidistant. This function can takes\nas input the tolerance, one of the 4 lists previously mentioned, and a function pointer\nthat describes how to calculate distance in the particualr direction of the list.\nIt also takes in by reference an iterator of a list which is used to collect the output.</p>\n<p>This is a recursive function that tries to find the <strong>largest</strong> sequence of equidistant\nobjects in a list and also outputs the distance between them. The function returns\ntrue if it finds a snap, and false otherwise.</p>\n<p>A brief description of the algorithm:</p>\n<ol>\n<li>Make a new list to hold the result.</li>\n<li>\n<p>FOR each object in a list</p>\n<p>2.1. If it’s at a particular distance from the next object</p>\n<ul>\n<li>Add the object to the result</li>\n<li>And call <code class=\"language-text\">_findSidewaysSnaps</code> with next object as the source object</li>\n</ul>\n<p>2.2. If the returned result has more objects than the previous result, use this and discard the previous one. </p>\n</li>\n<li>Now we have a list of the longest sequence of equidistant objects.</li>\n</ol>\n<h2 id=\"combining-results-from-different-directions\" style=\"position:relative;\"><a href=\"#combining-results-from-different-directions\" aria-label=\"combining results from different directions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Combining results from different directions</h2>\n<p><code class=\"language-text\">_findSidewaysSnaps</code> alone can only look at one list at a time. The function <code class=\"language-text\">_snapEquidistantPoints</code>\nis responsible for combining the resutls obtained for separate directions.</p>\n<p>Here is a simplification for looking for snaps to the Right:</p>\n<ol>\n<li>\n<p>IF <code class=\"language-text\">_findSidewaysSnaps</code> returns true for <code class=\"language-text\">_bboxes_right</code>.</p>\n<p>1.1. Add the equidistant bounding boxes to the list <code class=\"language-text\">vecRight</code>.</p>\n<p>1.2. Store the equal distance in <code class=\"language-text\">equalDist</code>.</p>\n<p>1.3. Now IF <code class=\"language-text\">_findSidewaysSnaps</code> returns true for <code class=\"language-text\">_bboxes_left</code> (looking left).</p>\n<ul>\n<li>\n<p>IF <code class=\"language-text\">equalDist</code> == <code class=\"language-text\">leftDist</code>.</p>\n<ul>\n<li>add the equidistant boxes on left to <code class=\"language-text\">vecRight</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Now <code class=\"language-text\">vecRight</code> has a list of all equidistant objects.</li>\n</ol>\n<p>This procedure is repeated for each direction.</p>\n<h2 id=\"case-with-overlapping-objects\" style=\"position:relative;\"><a href=\"#case-with-overlapping-objects\" aria-label=\"case with overlapping objects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Case with Overlapping objects</h2>\n<p>In case we have overlapping objects, it is useful that apart from probing them individually,\nwe also consider them to be a single object. This can be achieved with a simple hack.</p>\n<p>This involves, looking at each of the 4 lists, and add to them, the overall bounding boxes\nof objects that overlap. It is important that these new bounding boxes are inserted\nin such a way that the overall list remains sorted. The function <code class=\"language-text\">_addBBoxforIntersectingBBoxes</code>\ntakes care of this.</p>\n<p><img src=\"/9d98c2207dd8ebbe95f4128bb3cccd0b/overlap.svg\" alt=\"Image\"></p>\n<h1 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h1>\n<p>This was a very simple breakdown of how distribution snapping is implemented in inkscape.\nThere are an few more details that I have left out, which make this entire process\na little bit more efficient (like checking if the distance is withing tolerace before moving ahead).</p>","fields":{"slug":"/posts/gsoc2021-week6","tagSlugs":["/tag/g-so-c-21/","/tag/inkscape/"]},"frontmatter":{"date":"2021-06-30T06:31+00:00","description":"Week 6 progress on my GSoC Project at Inkscape","tags":["GSoC'21","Inkscape"],"title":"Week 6 - OnCanvas Alignment Guides","socialImage":{"publicURL":"/static/c7b626445e86bd4d36091b2a07161dac/snap.png"}}}},"pageContext":{"slug":"/posts/gsoc2021-week6"}},"staticQueryHashes":["251939775","401334301","825871152"]}